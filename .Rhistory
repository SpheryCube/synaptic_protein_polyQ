data_filtered <- proteinDfHMM %>% filter(proteinDfHMM$ensembl_peptide_id %in% kNeuronalTranscripts$V1)
write.csv(data_filtered, paste0(outputDir, substr(file, 1, nchar(file)-4), "_transcriptome_filt.csv"), row.names = FALSE)
}
}
}
}
kFlyNeuronalTranscripts
"FBpp0112339" %in% kFlyNeuronalTranscripts
"FBpp0073648" %in% kFlyNeuronalTranscripts
FBpp0112339 %in% kFlyNeuronalTranscripts
kFlyNeuronalTranscripts
"FBpp0112339" kFlyNeuronalTranscripts$V1
"FBpp0112339" %in% kFlyNeuronalTranscripts$V1
"FBpp0288505" %in% kFlyNeuronalTranscripts$V1
# Rbp6
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
# Rbp6
hmmType <- 'adjusted'
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
proteins <- proteins %>% filter(proteins$ensembl_peptide_id %in% set)
set <- c("FBpp0075045",
"FBpp0305994",
"FBpp0112339",
"FBpp0112340",
"FBpp0288505",
"FBpp0301711",
"FBpp0301712")
proteins <- proteins %>% filter(proteins$ensembl_peptide_id %in% set)
getwd()
####################################################
# Daniel Alfonsetti, daniel.alfonsetti@gmail.com
# MIT, Littleton Lab UROP
# 27 February 2019
# ---------------------------------
# Description: A script with functionality to take protein sequences and corresponding HMM annotations for that sequence
# and generate a plot divided by amino acid, showing the position of each amino acid of a certain type while overlayed by
# polyAA tracks denoted for that amino acid by the HMM.
####################################################
# Import libraries and set 'global' variables
####################################################
rm(list = ls())
source("C:/UROPs/polyQ_neuronal_proteins/scripts/ConstantsAndFunctions.R")
library(ggplot2)
library(reshape2)
library(dplyr)
#########################################
# Command Line Args (if using command line)
#########################################
args = commandArgs(trailingOnly=TRUE)
if (length(args) != 0) {
kModels =  unlist(strsplit(args[1],","))
kSpecies = unlist(strsplit(args[2],","))
}
######################################################
# Helper functions
######################################################
# Helper functions for plotting
# Helper function 1
PolyAAChart <- function(row, graphHasHMMannots = FALSE)  {
# Get indicies of each amino acid in the protein
peptideSeq <- as.character(row$peptideSeq)
aaPosList <- lapply(
kCandidateAAs,
function(AA)
unlist(lapply(
strsplit(peptideSeq, ''),
function(peptideSeq)
which(peptideSeq == AA)
))
)
########## Convert list to dataframe ############3
## Compute maximum length
maxLength <- max(sapply(aaPosList, length))
## Add NA values to list elements
aaPosList <- lapply(aaPosList, function(v) { c(v, rep(NA, maxLength-length(v)))})
## Cbind
df <- do.call(cbind, aaPosList)
colnames(df) <- kCandidateAAs
# Reorganize into a form useful for plotting
melted_df <- melt(df)[,c(-1)]
box_width = 7
p <- ggplot() +
geom_segment(aes(x=melted_df$value-box_width/2, xend = melted_df$value+box_width/2,
y=melted_df$Var2, yend = melted_df$Var2),
alpha = 1/box_width,
size = 8) +
xlab("Peptide Position Index") +
ylab("Amino Acid") +
ggtitle(paste0("Amino acid chart for ", row$external_gene_name, " (", row$ensembl_peptide_id, ")")) +
theme_light() +
theme(legend.position = "none")
if (graphHasHMMannots) {
hmmAnnotationsList <- lapply(
kCandidateAAs,
function(AA)
unlist(lapply(strsplit(as.character(eval(parse(text = paste0("row$indiciesPoly", AA)))), split = "; ")[[1]], function(i) eval(parse(text = i))))
)
# Remove first and last index in each list (because we plot each point as a line from its middle position to -1 and +1).
hmmAnnotationsList <- lapply(hmmAnnotationsList, function(vec){vec[2:(length(vec)-1)]})
# Find the vector with the max length, and pad the rest of the vectors so that we can convert the list to the dataframe.
maxLength <- max(sapply(hmmAnnotationsList, length))
hmmAnnotationsList <- lapply(hmmAnnotationsList, function(v) {if (is.na(v[1])) {rep(NA, maxLength)} else {c(v, rep(NA, maxLength-length(v)))}})
df <- do.call(cbind, hmmAnnotationsList)
colnames(df) <- kCandidateAAs
meltedHmmAnnotsDf <- melt(df)[,c(-1)]
if (!all(is.na(meltedHmmAnnotsDf$value))) {
p <- p + geom_segment(aes(x=meltedHmmAnnotsDf$value-1, xend = meltedHmmAnnotsDf$value+1,
y=meltedHmmAnnotsDf$Var2, yend = meltedHmmAnnotsDf$Var2),
alpha = 1, color = "Green", size = 2.5)
}
} #   if (graphHasHMMannots) {
print(p)
}
# Helper function 2
PolyAAChartWrapper <- function(proteins){
if (nrow(proteins) == 0){
plot(NA, xlim=c(0,2), ylim=c(0,2), bty='n',
xaxt='n', yaxt='n', xlab='', ylab='')
text(1, 1.7,"No data", cex = 4)
text(1, 1.4, "No proteins in this set had polyAA regions", cex = 1.5)
text(1, 1.2, "Cannot make amino acid plots", cex = 1.5)
} else {
for (i in 1:nrow(proteins)){
row <- proteins[i,]
PolyAAChart(row, TRUE)
}
}
}
# Helper function 3
# Function to check if any two intervals overlap
IsOverlap <- function(L) {
# Sort intervals in increasing order of start time
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (as.integer(L[[i-1]][2]) >= as.integer(L[[i]][1])){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
# Rbp6
hmmType <- 'adjusted'
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
set <- c("FBpp0075045",
"FBpp0305994",
"FBpp0112339",
"FBpp0112340",
"FBpp0288505",
"FBpp0301711",
"FBpp0301712")
proteins <- proteins %>% filter(proteins$ensembl_peptide_id %in% set)
pdf(file = paste0("AA_charts_Rbb6_isoforms_Model-", hmmType, "_fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
thisFileDir <- dirname(parent.frame(2)$ofile)
setwd(thisFileDir)
setwd(getSrcDirectory()[1])
getSrcDirectory()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
script.dir <- dirname(sys.frame(1)$ofile)
setwd("C:/UROPs/polyQ_neuronal_proteins/output/")
# Rbp6
hmmType <- 'adjusted'
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
set <- c("FBpp0075045",
"FBpp0305994",
"FBpp0112339",
"FBpp0112340",
"FBpp0288505",
"FBpp0301711",
"FBpp0301712")
proteins <- proteins %>% filter(proteins$ensembl_peptide_id %in% set)
pdf(file = paste0("AA_charts_Rbb6_isoforms_Model-", hmmType, "_fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
dir <- "C:/UROPs/polyQ_neuronal_proteins/output/exploratory"
dir.create(dir)
setwd(dir)
####################################################
# Daniel Alfonsetti, daniel.alfonsetti@gmail.com
# MIT, Littleton Lab UROP
# 24 January 2019
# ---------------------------------
# Description: For each amino acid, see if synaptic proteins are enriched for polyAA tracts.
# If our hypothesis is correct, synaptic proteins will only be enriched for polyQ tracts.
# We use a one sided fisher exact test for each amino acid.
# (2x2 matrix with rows and columsn of synaptic/not-synpatic and polyAA/not-polyAA, where polyAA for a protein is determined
# by HMM output, and synaptic/not-synaptic is determined by GO categories).
# After this, as a diagnostic, we analyze the distribution of the amino acid
# fraction of the polyAA regions of polyAA-denoted proteins
# for each of the 20 amino acids.
####################################################
rm(list = ls())
source("C:/UROPs/polyQ_neuronal_proteins/scripts/ConstantsAndFunctions.R")
# library(GO.db)
# library(biomaRt)
# library(biomartr)
library(ggplot2)
library(reshape2)
library(dplyr)
####################################################
# Get lists of various neuron categories so we can label proteins.
# We will annotate proteins based on whether they are in the category or not, and see if this relation is
# associated with whether they have a polyAA track.
####################################################
# Helper functions
####################################################
FisherTestComparison <- function(locationCats = NA,
isoformFilter = "on", nuclearFilter = "on", neurotransFilter = "on",
proteinsNoHmm = NA, modelSpeciesDir = NA) {
# Initialize variables
fisherTestResults <- rep(NA, length(kCandidateAAs)) # For the p-value barplot
aaFractionDf <- as.data.frame(matrix(ncol = 3, nrow = 0)) # For the AA fraction histograms
colnames(aaFractionDf) <- c("TractFraction", "AA", "label")
for (i in 1:length(kCandidateAAs)) {
candidateAA <- kCandidateAAs[i]
# debugging; candidateAA = kCandidateAAs[1]; candidateAA
print(paste0("Species: ", species,"; Amino acid: ", candidateAA, " Iter: ",i))
output_AA_dir <- paste0(modelSpeciesDir, candidateAA, "/")
dir.create(output_AA_dir, recursive = TRUE)
proteins <- read.csv(paste0(output_AA_dir, species, "_prots_w_HMM_", candidateAA, ".csv"))
###################
# Filtering Steps
###################
# remove isoforms unless one is polyAA and one is not, in which case, keep only one of each.
# Why do this? Fischer test assumes independence among samples for null distribution.
# For example, if synaptic proteins have more isoforms on average than other proteins,
# could mess up results.
if (isoformFilter == "on"){
proteins <- proteins[!duplicated(proteins[,c("ensembl_gene_id", "hmmHasPolyAA")]),]
}
if (nuclearFilter == "on") {
proteins$nuclear <- unlist(
lapply(
lapply(as.character(proteins$go_ids_CC), function(x){unlist(strsplit(x, "; "))}),
function(x){any(x %in% kNuclearCats)}
)
)
proteins = proteins %>% filter(proteins$nuclear == FALSE)
}
# kNeuronalTranscripts <- as.vector(read.table("C:/UROPs/polyQ_neuronal_proteins/output/fly_CNS_transcriptome_mh-l.txt", sep = "\t"))
if (neurotransFilter == "on") {
proteins <- proteins[proteins$ensembl_peptide_id %in% kNeuronalTranscripts$V1,]
}
###################
###################
# Labeling and p-value calculation steps.
# Annotate each protein as to whether it is in the GO category list or not.
proteins <- AnnotateByCategorySet(df = proteins, cats = locationCats)
if (length(unique(proteins$hmmHasPolyAA)) > 1 & length(unique(proteins$inSet)) > 1) {
p.val <- fisher.test(proteins$inSet, proteins$hmmHasPolyAA, alternative = "greater")
p.val <- p.val$p.value
} else {
p.val = 1
}
# For the p-value histograms
fisherTestResults[i] <- p.val
names(fisherTestResults)[i] <- candidateAA
# For the AA fraction histograms
polyAaDf <- proteins %>% filter(hmmHasPolyAA == TRUE)
if (nrow(polyAaDf) == 0) {
aaFractionDf <- rbind(aaFractionDf, data.frame(TractFraction = c(NA), AA = c(candidateAA), loc_label = c(NA)))
} else {
vec <- rep(candidateAA, length(polyAaDf$maxPolyAARegionAAFractions))
aaFractionDf <- rbind(aaFractionDf, data.frame(TractFraction = polyAaDf$maxPolyAARegionAAFractions, AA = vec , loc_label = polyAaDf$inSet))
}
} # for (i in 1:length(kCandidateAAs)) {
# p-value histogram
pvalHistDf = data.frame(names = factor(names(fisherTestResults), levels = names(fisherTestResults)),
pvalues = unlist(unname(fisherTestResults)))
p <- ggplot(pvalHistDf, aes(x = names, y = -log(pvalues), fill = pvalues)) +
geom_col(alpha = .5, show.legend = FALSE) +
theme_light() +
xlab("Amino Acid") +
ylab("-log(Fisher Test P-value)") +
ggtitle(paste0("Association between polyAA tract proteins and ", location, " proteins \n",
"Nuclear Filter: ", nuclearFilter, ", Isoform Filter: ", isoformFilter, ", Neuronal Filter: ", neurotransFilter)) +
geom_hline(yintercept = -log(0.05), linetype="dashed", color="orange") +
geom_hline(yintercept = -log(0.0025), linetype="dashed", color="red")
par(mfrow = c(1,1))
print(p)
#############################################
# AA fraction histograms
aaFractionDf$TractFraction <- as.numeric(aaFractionDf$TractFraction)
aaFractionDf <- aaFractionDf %>%
group_by(AA) %>%
mutate(med = median(TractFraction), mean = mean(TractFraction), group_count = dplyr::n(), group_count_cat = sum(loc_label))
aaFractionDf$group_count[is.na(aaFractionDf$TractFraction)] = 0
# Create dfs for text annotations
tmp <- aaFractionDf[!duplicated(aaFractionDf[,c("AA", "group_count", "group_count_cat")]),]
ann_text <- data.frame(label = paste0("Count: ", tmp$group_count), AA = tmp$AA)
ann_text_2 <- data.frame(label = paste0("Cat Count: ", tmp$group_count_cat), AA = tmp$AA)
p <- ggplot(aaFractionDf, aes(x = TractFraction)) +
geom_histogram() +
facet_wrap("AA", drop = FALSE) +
geom_vline(aes(xintercept = mean, group = AA), color = 'red') +
geom_text(data = ann_text, mapping = aes(x = -Inf,  y = Inf, label = label, hjust = 0, vjust = 1)) +
geom_text(data = ann_text_2, mapping = aes(x = -Inf,  y = Inf, label = label, hjust = 0, vjust = 2)) +
xlab("%AA of Largest Tract") +
ylab("Count") +
scale_x_continuous(lim = c(0, 1), labels = c("0", "0.25", "0.50", "0.75", "1")) +
theme_light()
if (neurotransFilter == "on") {
p <- p + ggtitle(paste0("Histograms of %AA of polyAA tracts (", species, ") \n",
"# of prots in neuronal transcriptome: ", nrow(kNeuronalTranscripts), "\n",
"# of prots in category (", location, "): ", sum(proteinsNoHmm$inSet), "\n",
"Nuclear Filter: ", nuclearFilter, ", Isoform Filter: ", isoformFilter, ", Neuronal Filter: ", neurotransFilter))
} else {
p <- p + ggtitle(paste0("Histograms of %AA of polyAA tracts (", species, ") \n",
"# of prots in genome: ", nrow(proteinsNoHmm), "\n",
"# of prots in category (", location, "): ", sum(proteinsNoHmm$inSet), "\n",
"Nuclear Filter: ", nuclearFilter, ", Isoform Filter: ", isoformFilter, ", Neuronal Filter: ", neurotransFilter))
}
par(mfrow = c(1,1))
print(p)
}
####################################################
# End of helper functions
####################################################
# Exploratory analysis
kLocations = list("AZ" = kAZcats, "Synapse" =  kSynapseCats, "PSD" = kPSDcats,
"Transcription_factor (+ cntrl)"= kTranscriptionCats,
"AZ+PSD" = c(kAZcats, kPSDcats))
for (model in kModels) {
for (species in kSpecies) {
for (location in names(kLocations)) {
modelSpeciesDir <- paste0(kOutputBaseDir, model, "/", species, "/")
fisherOutputDir <-  paste0(modelSpeciesDir, "AA_Fisher_Tests", "/")
dir.create(fisherOutputDir, recursive = TRUE)
pdf(file = paste0(fisherOutputDir, "/", species, "_AA_Fisher_Tests__Model-", model,
"__Location-", location, ".pdf"))
proteinsNoHmm <- read.csv(paste0(kOutputBaseDir, species, "_prots.csv"))
locationCats <- kLocations[[location]]
proteinsNoHmm <- AnnotateByCategorySet(df = proteinsNoHmm, cats = locationCats)
for (isoformFilter in c("on", "off")) {
for (nuclearFilter in c("on", "off")) {
for (neurotransFilter in c("on", "off")) {
print(paste0("Location: ", location))
print(paste0("Isoform filter: ", isoformFilter))
print(paste0("Nuclear filter: ", nuclearFilter))
FisherTestComparison(locationCats, isoformFilter, nuclearFilter, neurotransFilter, proteinsNoHmm, modelSpeciesDir)
} # for (neuronal_filter in c("on", "off")) {
}  # for (nuclearFilter in c("on", "off")) {
} # for (isoform in c("on", "off")) {
dev.off()
} #(location in names(kLocations)) {
} #for (species in kSpecies) {
} # for (model in kModels) {
# END
traceback()
?enrichGO
library(clusterProfiler)
?enrichGO
?enricher_internal
# Daniel Alfonsetti
# daniel.alfonsetti@gmail.com; alfonset@mit.edu
# MIT Littleton Lab
# 4 April, 2019
# Description: Use enrichment analysis to find GO gene categories that are enriched for
# proteins that contain a polyAA track as annoated by our HMM.
#########################################
# Load libraries
#########################################
rm(list = ls())
source("C:/UROPs/polyQ_neuronal_proteins/scripts/ConstantsAndFunctions.R")
library(clusterProfiler)
#########################################
# Setup environment
#########################################
setwd("C:/UROPs/polyQ_neuronal_proteins")
args = commandArgs(trailingOnly=TRUE)
if (length(args) != 0) {
kModels =  unlist(strsplit(args[1],","))
kSpecies = unlist(strsplit(args[2],","))
kCandidateAAs = strsplit(args[3],"")[[1]]
}
#########################################
# Helper function(s)
#########################################
MakeEnrichmentPlots <- function(goEnrichOutput, type, fileName) {
if (!is.null(goEnrichOutput)) {
write.csv(goEnrichOutput, file = paste0(fileName, ".csv"), row.names = FALSE)
pdf(paste0(fileName, "_plots.pdf"), width = 8.5, height = 11)
if (nrow(goEnrichOutput) != 0) {
par(mfrow = c(1, 1))
p1 <- barplot(goEnrichOutput, showCategory=8)
p2 <- dotplot(goEnrichOutput)
print(p1)
print(p2)
if (nrow(goEnrichOutput) != 0) {
p3 <- emapplot(goEnrichOutput)
print(p3)
}
} else {
plot(NA, xlim=c(0,2), ylim=c(0,2), bty='n',
xaxt='n', yaxt='n', xlab='', ylab='')
text(1,1.7,"No data", cex = 4)
text(1, 1.4, "No significant categories were found", cex = 2)
text(1, 1.2, "Cannot make enrichment plots", cex = 2)
} # if (nrow(goEnrichOutput) != 0) {
dev.off()
} # if (!is.null(goEnrichOutput)) {
} # MakeEnrichmentPlots()
#########################################
# Main
#########################################
for (model in kModels) {
for (species in kSpecies) {
for (candidateAA in kCandidateAAs) {
outputDir <- paste0(kOutputBaseDir, model, "/", species, "/", candidateAA, "/")
dir.create(outputDir, recursive = TRUE)
# Load in protein set data
proteins <- read.csv(paste0(outputDir, species, "_prots_w_HMM_", candidateAA, "_nuclear_filt_transcriptome_filt.csv"))
if (species == "fly") {
orgDb = org.Dm.eg.db
fromType = "FLYBASEPROT"
} else if (species == "human") {
orgDb = org.Hs.eg.db
fromType = "ENSEMBLPROT"
} else if (species == "mouse") {
orgDb = org.Mm.eg.db
fromType = "ENSEMBLPROT"
} else if (species == "worm") {
orgDb = org.Ce.eg.db
fromType = "ENSEMBLPROT"
}
# Do enrichment for each subontology of GO
#########################################
# clusterProfiler Part 1 - GO
#########################################
for (goOnt in c("all")) {
# goOnt <- "BP"
print(paste0("Doing enrichment analysis for ", goOnt, " ontology."))
# Only allow proteins that have annotations in current ontology to be in background universe.
proteinsHasOntType <- proteins %>% filter(!is.na(eval(parse(text=paste0("go_ids_", goOnt)))))
nrow(proteins); nrow(proteinsHasOntType)
# Get universe of proteins list
proteinsVec <- proteinsHasOntType$ensembl_peptide_id
# Get significant proteins list
polyAAProteinsVec <- proteinsHasOntType %>%
filter(hmmHasPolyAA) %>%
dplyr::select(c(ensembl_peptide_id))
polyAAProteinsVec <- polyAAProteinsVec$ensembl_peptide_id
# Get mapping from ensembl to entrez (entrez ids are needed for enrichment analysis)
# Create vector of  entrez ids for significant genes.
# Not there can be a 1 to many mapping from ensembl to entrez in the above step.
# thus we need to use 'unique'.
universeDf <- bitr(proteinsVec,
fromType = fromType,
toType = c("ENTREZID", "SYMBOL"),
OrgDb = orgDb)
universeGenes <- unique(universeDf$ENTREZID)
sigDf <- bitr(polyAAProteinsVec,
fromType = fromType,
toType = c("ENTREZID", "SYMBOL"),
OrgDb = orgDb)
sigGenes <- unique(sigDf$ENTREZID)
# Create vector of entrez ids for a random set of genes that is the same size
# of the set of significant genes in order to control for sample size. (FDR adjustment should do this,
# but we are going to add this step just for kicks)
# Create vector of random control genes with same number as significant genes.
controlGenes <- sample(universeGenes, length(sigGenes))
# print(paste0("Length control genes: ", length(controlGenes)))
goEnrichOutputTest <- enrichGO(gene = sigGenes,
universe = universeGenes,
OrgDb = orgDb,
ont = goOnt,
pAdjustMethod = "BH",
pvalueCutoff = 0.05,
qvalueCutoff = 0.05,
readable = TRUE)
# Control group
goEnrichOutputControl <- enrichGO(gene = controlGenes,
universe = universeGenes,
OrgDb = orgDb,
ont = goOnt,
pAdjustMethod = "BH",
pvalueCutoff = 1,
qvalueCutoff = 1,
readable = TRUE)
enrichmentOutputDir <- paste0(paste0(outputDir, "/GO_Enrichment_", goOnt))
dir.create(enrichmentOutputDir)
fileName = paste0(paste0(outputDir, "/GO_Enrichment_", goOnt, "/GO_", goOnt, "_results_CONTROL"))
MakeEnrichmentPlots(goEnrichOutputControl, type = "control", fileName = fileName)
fileName = paste0(paste0(outputDir, "/GO_Enrichment_", goOnt, "/GO_", goOnt, "_results"))
MakeEnrichmentPlots(goEnrichOutputTest, type = "test", fileName = fileName)
} # for (goOnt in c("BP", "MF", "CC")) {
} # for (candidateAA in kCandidateAAs) {
} # for (species in kSpecies) {
} # for (model in kModels) {
# END
p <- read.csv("C:/UROPs/polyQ_neuronal_proteins/output/adjusted/fly/Q/fly_prots_w_HMM_Q.csv")
View(p)
View(p)
ensembl <- useMart("ensembl", dataset = "dmelanogaster_gene_ensembl")
library(dplyr)
# Biological databases and their tools
library(biomaRt)
library(org.Dm.eg.db)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(org.Ce.eg.db)
ensembl <- useMart("ensembl", dataset = "dmelanogaster_gene_ensembl")
listAttributes(ensembl)
a <- listAttributes(ensembl)
View(a)
View(a)
