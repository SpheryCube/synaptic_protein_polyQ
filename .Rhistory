unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE),
recursive = FALSE))
intervals_list <-
unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE),
), recursive = FALSE)
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE),
), recursive = FALSE)
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE)), recursive = FALSE)
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE)))
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE)))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
samples <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervals_list <- apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
View(intervals_list)
# L = intervals_list[[40]]
L = intervals_list[[42]]
L
# Sort intervals in increasing order of start time
L = L[order(unlist(lapply(L, function(x) x[1])), decreasing=FALSE)]
L
# Sort intervals in increasing order of start time
L = L[order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)]
# L = intervals_list[[40]]
L = intervals_list[42]
:
L
# L = intervals_list[[40]]
L = intervals_list[42]
# L = intervals_list[[40]]
L = intervals_list[[42]]
lapply(L, function(x) x[1])
order(unlist(lapply(L, function(x) x[1]))
order(unlist(lapply(L, function(x) x[1])))
order(unlist(lapply(L, function(x) x[1])), decreasing=FALSE)
order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)
# Sort intervals in increasing order of start time
L = L[order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)]
L
# Function to check if any two intervals overlap
isOverlap <- function(L) {
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
L = L[order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (L[[i-1]][2] > L[[i]][1]){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
res <- unlist(lapply(intervals_list, isOverlap)) # O(n)
proteins <- proteins[res,]
View(proteins)
L = intervals_list[[40]]
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
L = L[order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)]
L
unlist(lapply(L, function(x) x[1]))
L = intervals_list[[40]]
unlist(lapply(L, function(x) x[1]))
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
L = intervals_list[[40]]
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
L = intervals_list[[40]]
unlist(lapply(L, function(x) x[1]))
L = L[order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)]
L
order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)
unlist(lapply(L, function(x) x[1]))
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
L = intervals_list[[40]]
unlist(lapply(L, function(x) x[1]))
as.integer(unlist(lapply(L, function(x) x[1])))
order(unlist(lapply(L, function(x) x[1])), decreasing=TRUE)
order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
L
L = intervals_list[[42]]
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
L
# Function to check if any two intervals overlap
isOverlap <- function(L) {
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
# L = intervals_list[[40]]
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (L[[i-1]][2] > L[[i]][1]){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
res <- unlist(lapply(intervals_list, isOverlap)) # O(n)
proteins <- proteins[res,]
View(proteins)
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
samples <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervals_list <- apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
# Function to check if any two intervals overlap
isOverlap <- function(L) {
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
# L = intervals_list[[40]]
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (L[[i-1]][2] > L[[i]][1]){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
res <- unlist(lapply(intervals_list, isOverlap)) # O(n)
proteins <- proteins[res,]
View(proteins)
L = intervals_list[[78]]
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (L[[i-1]][2] > L[[i]][1]){
return(TRUE)
}
}
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (L[[i-1]][2] > L[[i]][1]){
print('hi')
return(TRUE)
}
}
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (L[[i-1]][2] > L[[i]][1]){
print(i)
return(TRUE)
}
}
L[i]
L[[2]]
L[[2]][2]
L[[3][1]
L[[3]][1]
L[[i-1]][2] > L[[i]][1]
L[[i-1]][2]
L[[i]][1]
# Function to check if any two intervals overlap
isOverlap <- function(L) {
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
# L = intervals_list[[78]]
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (as.integer(L[[i-1]][2]) > as.integer(L[[i]][1])){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
res <- unlist(lapply(intervals_list, isOverlap)) # O(n)
proteins <- proteins[res,]
View(proteins)
intervals_list <- apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
View(intervals_list)
View(intervals_list)
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE)), recursive = FALSE)
View(intervals_list)
View(intervals_list)
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
as.integer(strsplit(as.character(y), ":")))),
recursive = FALSE)), recursive = FALSE)
# Function to check if any two intervals overlap
isOverlap <- function(L) {
# L = intervals_list[[40]]
# L = intervals_list[[42]]
# Sort intervals in increasing order of start time
# L = intervals_list[[78]]
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap (O(20))
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (as.integer(L[[i-1]][2]) > as.integer(L[[i]][1])){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
samples <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE)), recursive = FALSE)
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervals_list, IsOverlap))
proteins <- proteins[res,]
# Only plot proteins that have overlapping polyAA regions.
pdf(file = paste0("AA_charts_overlappingPolyAAs__Model-", hmmType, "__fly.pdf"))
dev.off()
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
samples <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE)), recursive = FALSE)
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervals_list, IsOverlap))
proteins <- proteins[res,]
# Helper function 3
# Function to check if any two intervals overlap
IsOverlap <- function(L) {
# Sort intervals in increasing order of start time
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (as.integer(L[[i-1]][2]) > as.integer(L[[i]][1])){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
samples <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervals_list <- unlist(apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE)), recursive = FALSE)
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervals_list, IsOverlap))
proteins <- proteins[res,]
intervals_list
View(intervals_list)
View(intervals_list)
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
samples <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervals_list <- apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervals_list, IsOverlap))
proteins <- proteins[res,]
# Only plot proteins that have overlapping polyAA regions.
pdf(file = paste0("AA_charts_overlappingPolyAAs__Model-", hmmType, "__fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
# Helper function 2
PolyAAChartWrapper <- function(proteins){
if (nrow(proteins) == 0){
plot(NA, xlim=c(0,2), ylim=c(0,2), bty='n',
xaxt='n', yaxt='n', xlab='', ylab='')
text(1, 1.7,"No data", cex = 4)
text(1, 1.4, "No proteins in this set had polyAA regions", cex = 1.5)
text(1, 1.2, "Cannot make amino acid plots", cex = 1.5)
} else {
for (i in 1:nrow(proteins)){
row <- proteins[i,]
PolyAAChart(row, TRUE)
}
}
}
# Helper functions for plotting
# Helper function 1
PolyAAChart <- function(row, graphHasHMMannots = FALSE)  {
# Get indicies of each amino acid in the protein
peptideSeq <- as.character(row$peptideSeq)
aaPosList <- lapply(
kCandidateAAs,
function(AA)
unlist(lapply(
strsplit(peptideSeq, ''),
function(peptideSeq)
which(peptideSeq == AA)
))
)
########## Convert list to dataframe ############3
## Compute maximum length
maxLength <- max(sapply(aaPosList, length))
## Add NA values to list elements
aaPosList <- lapply(aaPosList, function(v) { c(v, rep(NA, maxLength-length(v)))})
## Cbind
df <- do.call(cbind, aaPosList)
colnames(df) <- kCandidateAAs
# Reorganize into a form useful for plotting
melted_df <- melt(df)[,c(-1)]
box_width = 7
p <- ggplot() +
geom_segment(aes(x=melted_df$value-box_width/2, xend = melted_df$value+box_width/2,
y=melted_df$Var2, yend = melted_df$Var2),
alpha = 1/box_width,
size = 8) +
xlab("Peptide Position Index") +
ylab("Amino Acid") +
ggtitle(paste0("Amino acid chart for ", row$external_gene_name, " (", row$ensembl_peptide_id, ")")) +
theme_light() +
theme(legend.position = "none")
if (graphHasHMMannots) {
hmmAnnotationsList <- lapply(
kCandidateAAs,
function(AA)
unlist(lapply(strsplit(as.character(eval(parse(text = paste0("row$indiciesPoly", AA)))), split = "; ")[[1]], function(i) eval(parse(text = i))))
)
# Remove first and last index in each list (because we plot each point as a line from its middle position to -1 and +1).
hmmAnnotationsList <- lapply(hmmAnnotationsList, function(vec){vec[2:(length(vec)-1)]})
# Find the vector with the max length, and pad the rest of the vectors so that we can convert the list to the dataframe.
maxLength <- max(sapply(hmmAnnotationsList, length))
hmmAnnotationsList <- lapply(hmmAnnotationsList, function(v) {if (is.na(v[1])) {rep(NA, maxLength)} else {c(v, rep(NA, maxLength-length(v)))}})
df <- do.call(cbind, hmmAnnotationsList)
colnames(df) <- kCandidateAAs
meltedHmmAnnotsDf <- melt(df)[,c(-1)]
if (!all(is.na(meltedHmmAnnotsDf$value))) {
p <- p + geom_segment(aes(x=meltedHmmAnnotsDf$value-1, xend = meltedHmmAnnotsDf$value+1,
y=meltedHmmAnnotsDf$Var2, yend = meltedHmmAnnotsDf$Var2),
alpha = 1, color = "Green", size = 2.5)
}
} #   if (graphHasHMMannots) {
print(p)
}
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
samples <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervals_list <- apply(samples, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervals_list, IsOverlap))
proteins <- proteins[res,]
# Only plot proteins that have overlapping polyAA regions.
pdf(file = paste0("AA_charts_overlappingPolyAAs__Model-", hmmType, "__fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
# Only plot proteins that have overlapping polyAA regions.
pdf(file = paste0("AA_charts_overlappingPolyAAs__Model-", hmmType, "__fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
intervalData <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervalsList <- apply(intervalData, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervalsList, IsOverlap))
proteins <- proteins[res,]
# Only plot proteins that have overlapping polyAA regions.
pdf(file = paste0("AA_charts_overlappingPolyAAs__Model-", hmmType, "__fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
# Helper function 3
# Function to check if any two intervals overlap
IsOverlap <- function(L) {
# Sort intervals in increasing order of start time
L = L[order(as.integer(unlist(lapply(L, function(x) x[1]))), decreasing=FALSE)]
# In the sorted array, if start time of an interval
# is less than end of previous interval, then there
# is an overlap
for (i in 2:length(L)) {
if (is.na(L[i-1]) | is.na(L[i])) {next}
if (as.integer(L[[i-1]][2]) >= as.integer(L[[i]][1])){
return(TRUE)
}
}
#If we reach here, then no overlap
return(FALSE)
}
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervalsList, IsOverlap))
proteins <- proteins[res,]
# Only plot proteins that have overlapping polyAA regions.
pdf(file = paste0("AA_charts_overlappingPolyAAs__Model-", hmmType, "__fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
intervalData <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervalsList <- apply(intervalData, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
# Find which proteins have overlapping polyAA regions
res <- unlist(lapply(intervalsList, IsOverlap))
proteins <- proteins[res,]
# Only plot proteins that have overlapping polyAA regions.
pdf(file = paste0("AA_charts_overlappingPolyAAs__Model-", hmmType, "__fly.pdf"))
PolyAAChartWrapper(proteins)
dev.off()
intervalsList[[13]]
dir.create(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts"))
setwd(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/AA_charts/"))
proteins <- read.csv(paste0("C:/UROPs/polyQ_neuronal_proteins/output/", hmmType, "/fly/mergedPolyAaDf.csv"))
intervalData <- proteins[,(ncol(proteins)-20+1):ncol(proteins)] # Only get the columns with polyAA intervals
intervalsList <- apply(intervalData, 1, function(row)
unlist(sapply(row, function(x)
lapply(strsplit(as.character(x), "; "), function(y)
strsplit(as.character(y), ":"))),
recursive = FALSE))
intervalsList[[13]]
proteins[[13]]
View(proteins)
View(proteins)
proteins[13,]
proteins[12,]
